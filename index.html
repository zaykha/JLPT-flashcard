<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JLPT Vocabulary Kanji Flash Card — N3 (cache-fix)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap");

      body {
        font-family: "Inter", "Noto Sans JP", sans-serif;
        background: #111827;
        color: #f3f4f6;
      }
      .flashcard-container {
        perspective: 1200px;
      }
      .flashcard {
        width: 100%;
        height: 320px;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.7s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
      }
      .flashcard.is-flipped {
        transform: rotateY(180deg);
      }
      .flashcard-face {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        border-radius: 1.5rem;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 2rem;
        text-align: center;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2),
          0 10px 10px -5px rgba(0, 0, 0, 0.1);
        border: 1px solid #374151;
      }

      /* Vocab faces */
      .flashcard-front {
        background: linear-gradient(145deg, #1f2937, #374151);
      }
      .flashcard-back {
        background: linear-gradient(145deg, #166534, #15803d);
        color: #f0fdf4;
        transform: rotateY(180deg);
      }

      #front-text {
        font-size: clamp(3.5rem, 16vw, 7rem);
        font-weight: 700;
        margin-bottom: 0.5rem;
      }
      #english-back {
        font-size: clamp(1.4rem, 6vw, 2.4rem);
        font-weight: 700;
      }
      #hiragana-back {
        font-size: clamp(1rem, 4vw, 1.4rem);
        color: #cbd5e1;
        margin-bottom: 0.25rem;
      }
      #kanji-back {
        font-size: clamp(1.8rem, 7vw, 2.8rem);
        font-weight: 700;
        margin-top: 0.25rem;
      }

      /* Grammar helpers */
      .flashcard-face--back {
        transform: rotateY(180deg);
      }
      #grammar-strength-tag {
        font-size: 0.75rem;
        white-space: nowrap;
      }
      .metric-strip {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .metric-strip .bar-wrap {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .metric-strip .bar {
        width: 5.5rem;
        height: 0.625rem;
        border-radius: 9999px;
        background: #374151;
        overflow: hidden;
      }
      .metric-strip .bar > div {
        height: 100%;
        border-radius: 9999px;
      }
      /* Front text size when showing English (Eng→JP mode) */
      #front-text.front-english {
        /* much smaller and wraps nicely */
        font-size: clamp(1.25rem, 5.5vw, 2.2rem);
        line-height: 1.35;
        word-break: break-word;
        hyphens: auto;
        padding: 0 0.5rem;
      }
      .topic-card {
        border: 1px solid #374151;
      }
      .topic-card.selected {
        outline: 2px solid #22c55e;
      }
      /* Sticky containers */
      .sticky-top {
        position: sticky;
        top: 0;
        z-index: 30;
      }
      .sticky-bottom {
        position: sticky;
        bottom: 0;
        z-index: 30;
      }

      /* Topic pills (display-only) */

      .pill + .pill {
        margin-left: 0.5rem;
      }
      .choice-btn {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 0.6rem 0.75rem;
        border-radius: 0.75rem;
        background: #1f2937;
        color: #e5e7eb;
        border: 1px solid #374151;
        text-align: center;
        transition: transform 0.06s ease;
      }
      .choice-btn:active {
        transform: scale(0.99);
      }
      .choice-btn.correct {
        outline: 2px solid #10b981;
        background: rgba(16, 185, 129, 0.08);
      }
      .choice-btn.wrong {
        outline: 2px solid #ef4444;
        background: rgba(239, 68, 68, 0.08);
      }
      .choice-jp-kana {
        font-size: 0.85rem;
        color: #cbd5e1;
        line-height: 1.1;
      }
      .choice-jp-kanji {
        font-size: 1.35rem;
        font-weight: 700;
        line-height: 1.15;
      }
      .choice-en {
        font-size: 1rem;
        font-weight: 600;
      }

      /* Topic card selection */
      .topic-card {
        border: 1px solid #374151;
      }
      .topic-card.selected {
        outline: 2px solid #22c55e;
        background-color: rgba(34, 197, 94, 0.06);
      }

      /* Icon in topic card */
      .topic-icon {
        width: 28px;
        height: 28px;
        flex: 0 0 28px;
        opacity: 0.9;
      }

      @media (max-width: 640px) {
        body {
          padding: 1rem;
        }
        .flashcard {
          height: 250px;
        }
        .metric-strip .bar {
          width: 4.25rem;
        }
      }
    </style>
  </head>
  <body
    class="p-4 sm:p-8 flex flex-col items-center justify-center min-h-screen"
  >
    <div class="w-full max-w-lg mx-auto">
      <header class="text-center mb-4 sm:mb-8">
        <h1
          class="text-3xl sm:text-5xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-emerald-400 to-cyan-400 pb-2"
        >
          Flashcard Memory
        </h1>
        <p
          id="sub-header-text"
          class="text-gray-400 text-sm sm:text-base mt-2"
        ></p>
      </header>

      <!-- Password -->
      <div id="password-ui" class="w-full mb-6">
        <div
          class="p-4 rounded-lg bg-gray-800 border border-gray-700 text-center"
        >
          <input
            type="password"
            id="password-input"
            placeholder="Enter password"
            class="w-full p-2 mb-4 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500"
          />
          <button
            id="password-btn"
            class="w-full py-3 bg-gradient-to-r from-purple-600 to-indigo-700 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md text-lg"
          >
            Log In
          </button>
        </div>
      </div>

      <!-- Level selection -->
      <div id="level-selection-ui" class="w-full mb-6 hidden">
        <div
          class="p-4 rounded-lg bg-gray-800 border border-gray-700 text-center"
        >
          <h3 class="text-lg font-bold mb-4">Choose Your Level</h3>
          <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
            <button
              class="level-btn w-full py-3 bg-gradient-to-r from-purple-600 to-indigo-700 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md text-xl"
              data-level="N4"
            >
              N4
            </button>
            <button
              class="level-btn w-full py-3 bg-gradient-to-r from-purple-600 to-indigo-700 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md text-xl"
              data-level="N3"
            >
              N3
            </button>
            <button
              class="level-btn w-full py-3 bg-gradient-to-r from-purple-600 to-indigo-700 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md text-xl"
              data-level="N2"
            >
              N2
            </button>
            <button
              class="level-btn w-full py-3 bg-gradient-to-r from-purple-600 to-indigo-700 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md text-xl"
              data-level="N1"
            >
              N1
            </button>
          </div>
        </div>
      </div>

      <!-- Study mode -->
      <div id="study-mode-selection-ui" class="w-full mb-6 hidden">
        <div
          class="p-4 rounded-lg bg-gray-800 border border-gray-700 text-center"
        >
          <h3 id="mode-header" class="text-lg font-bold mb-4">
            You chose <span id="selected-level"></span>. Now, choose a study
            mode.
          </h3>
          <div class="grid grid-cols-2 gap-4">
            <button
              id="vocab-mode-btn"
              class="w-full py-3 bg-gradient-to-r from-emerald-600 to-teal-700 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md text-lg"
            >
              <i class="fas fa-book mr-2"></i>Vocabulary
            </button>
            <button
              id="grammar-mode-btn"
              class="w-full py-3 bg-gradient-to-r from-rose-600 to-pink-700 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md text-lg"
            >
              <i class="fas fa-pen-nib mr-2"></i>Grammar
            </button>
          </div>
          <button
            id="back-to-level-btn"
            class="mt-4 py-2 px-4 bg-gradient-to-r from-gray-700 to-gray-600 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md"
          >
            <i class="fas fa-arrow-left mr-2"></i>Back to Levels
          </button>
        </div>
      </div>

      <!-- Vocab input -->
      <div id="flashcard-input-ui" class="w-full mb-6 hidden">
        <!-- Sticky top bar -->
        <div
          class="sticky-top bg-gray-800/95 backdrop-blur border-b border-gray-700 -mx-4 px-4 pt-3 pb-2"
        >
          <div class="flex items-center justify-between">
            <button
              id="settings-back-btn"
              class="px-3 py-2 text-sm bg-gray-700 hover:bg-gray-600 text-white rounded-lg"
            >
              ← Back
            </button>

            <!-- Words/day pill (B2 mini number input) -->
            <label class="pill gap-2">
              <span>Words/day</span>
              <input
                id="per-day-input"
                type="number"
                min="5"
                value="20"
                class="w-16 ml-1 px-2 py-1 rounded bg-gray-800 border border-gray-600 text-gray-100 text-xs focus:outline-none"
              />
            </label>
          </div>

          <!-- Selected topics (display-only pills) -->
          <div id="selected-pill-row" class="mt-2 flex flex-wrap gap-2"></div>
        </div>

        <!-- Scrollable content: topic progress grid -->
        <div class="pt-3">
          <div id="topic-progress-grid" class="grid grid-cols-1 gap-3"></div>

          <!-- Legend -->
          <div
            class="mt-2 text-[11px] text-gray-400 flex flex-wrap gap-3 items-center"
          >
            <span class="inline-flex items-center gap-1"
              ><span class="inline-block w-3 h-3 rounded bg-rose-500"></span
              >New</span
            >
            <span class="inline-flex items-center gap-1"
              ><span class="inline-block w-3 h-3 rounded bg-amber-500"></span
              >1d</span
            >
            <span class="inline-flex items-center gap-1"
              ><span class="inline-block w-3 h-3 rounded bg-yellow-500"></span
              >3d</span
            >
            <span class="inline-flex items-center gap-1"
              ><span class="inline-block w-3 h-3 rounded bg-sky-500"></span
              >7d</span
            >
            <span class="inline-flex items-center gap-1"
              ><span class="inline-block w-3 h-3 rounded bg-indigo-500"></span
              >14d</span
            >
            <span class="inline-flex items-center gap-1"
              ><span class="inline-block w-3 h-3 rounded bg-emerald-500"></span
              >30d</span
            >
          </div>
        </div>

        <!-- Sticky bottom action buttons -->
        <div
          class="sticky-bottom -mx-4 px-4 pt-3 pb-3 bg-gradient-to-t from-gray-900 via-gray-900/70 to-transparent"
        >
          <div class="grid grid-cols-2 gap-3">
            <button
              id="generate-kanji-to-english-btn"
              class="w-full py-3 bg-gradient-to-r from-emerald-600 to-teal-700 hover:opacity-90 transition-opacity text-white font-bold rounded-lg shadow-md text-base"
            >
              Kanji → Eng
            </button>
            <button
              id="generate-english-to-kanji-btn"
              class="w-full py-3 bg-gradient-to-r from-blue-600 to-cyan-700 hover:opacity-90 transition-opacity text-white font-bold rounded-lg shadow-md text-base"
            >
              Eng → JP
            </button>
          </div>
        </div>
      </div>

      <!-- Vocab flashcard -->
      <div id="flashcard-ui" class="hidden">
        <div class="flashcard-container w-full mb-6">
          <div id="flashcard" class="flashcard">
            <div id="flashcard-front" class="flashcard-face flashcard-front">
              <h2 id="front-text"></h2>
            </div>
            <div id="flashcard-back" class="flashcard-face flashcard-back">
              <p id="hiragana-back" class="text-xl text-gray-200 mb-2"></p>
              <h2 id="kanji-back" class="text-3xl font-bold"></h2>
              <h2 id="english-back" class="text-3xl font-bold"></h2>
            </div>
          </div>
        </div>

        <div class="flex flex-row justify-center items-center gap-4 mb-4">
          <button
            id="pronunciation-btn"
            class="py-3 px-6 bg-gradient-to-r from-gray-700 to-gray-600 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md text-lg"
          >
            <i class="fas fa-volume-up"></i>
          </button>
          <button
            id="previous-btn"
            class="py-3 px-6 bg-gradient-to-r from-gray-700 to-gray-600 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md"
          >
            <i class="fas fa-arrow-left"></i>
          </button>
          <button
            id="shuffle-btn"
            class="py-3 px-6 bg-gradient-to-r from-gray-700 to-gray-600 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md"
          >
            <i class="fas fa-random"></i>
          </button>
          <button
            id="next-btn"
            class="py-3 px-6 bg-gradient-to-r from-emerald-600 to-teal-700 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md"
          >
            <i class="fas fa-arrow-right"></i>
          </button>
        </div>

        <div class="flex flex-row justify-center items-center gap-4 mb-2">
          <button
            id="again-btn"
            class="py-2 px-5 bg-rose-600 hover:bg-rose-700 text-white font-bold rounded-lg shadow-md"
          >
            Again
          </button>
          <button
            id="gotit-btn"
            class="py-2 px-5 bg-emerald-600 hover:bg-emerald-700 text-white font-bold rounded-lg shadow-md"
          >
            Got it
          </button>
        </div>

        <div class="w-full grid grid-cols-1 gap-4">
          <button
            id="back-to-mode-btn"
            class="w-full py-3 bg-gradient-to-r from-gray-800 to-gray-700 hover:opacity-80 transition-opacity duration-300 text-white font-bold rounded-lg shadow-md"
          >
            Back to Study Modes
          </button>
        </div>
        <div
          id="card-count"
          class="text-center text-gray-500 font-semibold text-xl mt-4"
        ></div>
      </div>

      <!-- MCQ Quiz (hidden until study completes) -->
      <div id="quiz-ui" class="hidden">
        <div class="mb-3 flex items-center justify-between">
          <button
            id="quiz-exit-btn"
            class="px-3 py-2 text-sm bg-gray-700 hover:bg-gray-600 text-white rounded-lg"
          >
            ← Back to Settings
          </button>
          <div id="quiz-progress" class="text-sm text-gray-300"></div>
        </div>

        <div
          id="quiz-card"
          class="p-4 rounded-2xl bg-gray-800 border border-gray-700"
        >
          <div
            id="quiz-prompt"
            class="text-lg font-semibold text-gray-100 mb-4"
          ></div>

          <!-- Choices -->
          <div id="quiz-choices" class="grid grid-cols-1 gap-3"></div>

          <div id="quiz-feedback" class="mt-3 text-sm text-gray-300"></div>
        </div>

        <!-- Bottom actions -->
        <div class="mt-4 grid grid-cols-2 gap-3">
          <button
            id="quiz-prev-btn"
            class="px-4 py-3 bg-gray-700 text-white rounded-lg"
          >
            Previous
          </button>
          <button
            id="quiz-next-btn"
            class="px-4 py-3 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg font-bold"
          >
            Next
          </button>
        </div>
      </div>

      <!-- Grammar -->
      <div
        id="grammar-ui"
        class="w-full max-w-lg mx-auto flex flex-col items-center justify-center hidden"
      >
        <div id="grammar-part-selection" class="w-full text-center">
          <p id="grammar-loading-message" class="text-lg text-gray-400 mb-6">
            Loading grammar data...
          </p>
        </div>

        <div id="grammar-flashcard-app" class="w-full" style="display: none">
          <button
            id="grammar-back-button"
            class="mb-4 px-4 py-2 bg-gray-700 text-white font-semibold rounded-lg shadow hover:bg-gray-600 transition-colors"
          >
            ← Back to Parts
          </button>

          <div class="flashcard-container mb-6">
            <div
              id="grammar-flashcard"
              class="flashcard h-[400px] sm:h-[420px]"
            >
              <!-- FRONT (English example) -->
              <div
                id="grammar-flashcard-front"
                class="flashcard-face bg-gray-800 text-gray-200 p-6 sm:p-8"
              >
                <p class="text-xl sm:text-2xl font-semibold"></p>
              </div>

              <!-- BACK (Japanese details) -->
              <div
                id="grammar-flashcard-back"
                class="flashcard-face flashcard-face--back bg-gray-800 text-gray-300 p-6 sm:p-8 text-left"
              >
                <div class="w-full metric-strip mb-4">
                  <span
                    class="text-xs sm:text-sm font-bold text-white px-2 py-1 rounded-full"
                    id="grammar-strength-tag"
                  ></span>
                  <div class="bar-wrap">
                    <div class="bar">
                      <div
                        id="grammar-directness-bar"
                        class="bg-blue-500"
                        style="width: 0%"
                      ></div>
                    </div>
                    <span
                      class="text-xs sm:text-sm text-gray-400 whitespace-nowrap"
                      >Directness</span
                    >
                  </div>
                  <div class="bar-wrap">
                    <div class="bar">
                      <div
                        id="grammar-politeness-bar"
                        class="bg-green-500"
                        style="width: 0%"
                      ></div>
                    </div>
                    <span
                      class="text-xs sm:text-sm text-gray-400 whitespace-nowrap"
                      >Politeness</span
                    >
                  </div>
                </div>
                <h2
                  id="grammar-name"
                  class="text-2xl sm:text-3xl font-extrabold text-white mb-1"
                ></h2>
                <h3
                  id="grammar-meaning"
                  class="text-base sm:text-lg font-medium text-gray-300 mb-1"
                ></h3>
                <p
                  id="grammar-form"
                  class="text-sm sm:text-base text-gray-400 mb-4"
                ></p>
                <hr class="w-full border-gray-600 mb-4" />
                <p
                  id="grammar-japanese-example"
                  class="text-xl sm:text-2xl font-bold text-white mb-3"
                ></p>
                <p
                  id="grammar-key-point"
                  class="text-sm sm:text-base text-gray-300"
                ></p>
              </div>
            </div>
          </div>

          <div class="flex justify-center space-x-4">
            <button
              id="grammar-prev-button"
              class="px-6 py-3 bg-gray-700 text-white font-bold rounded-full shadow-lg hover:bg-gray-600 transition-colors"
            >
              Previous
            </button>
            <button
              id="grammar-next-button"
              class="px-6 py-3 bg-blue-500 text-white font-bold rounded-full shadow-lg hover:bg-blue-600 transition-colors"
            >
              Next
            </button>
          </div>
        </div>

        <button
          id="back-from-grammar-btn"
          class="mt-8 py-3 px-6 bg-gray-800 hover:bg-gray-700 transition-colors duration-300 text-white font-bold rounded-lg shadow-md"
        >
          <i class="fas fa-arrow-left mr-2"></i>Back to Study Modes
        </button>
      </div>
    </div>

    <script>
      // ======= URLs (renamed) =======
      const n3vocaburl =
        "https://docs.google.com/spreadsheets/d/e/2PACX-1vRBBLGqGXdeAH0sY255sFHikYF8-GA6ShxGZP9Gy_zoGyBu3NQpl7qNtDLvAdRScNiGAsy_lRGpcixH/pub?gid=1229152076&single=true&output=csv";
      const n3grammarUrl =
        "https://docs.google.com/spreadsheets/d/e/2PACX-1vRBBLGqGXdeAH0sY255sFHikYF8-GA6ShxGZP9Gy_zoGyBu3NQpl7qNtDLvAdRScNiGAsy_lRGpcixH/pub?gid=1990687568&single=true&output=csv";
      const JLPT_API_BASE = "https://jlpt-vocab-api.vercel.app";
      // map your UI level (N1..N5) to API numeric level (1..5)
      const levelStrToNum = (lvl) =>
        ({ N1: 1, N2: 2, N3: 3, N4: 4, N5: 5 }[lvl] ?? 3);
      const correctPassword = "486237abC";
      const passwordCacheKey = "jlpt-app-password";

      // State
      let words = [];
      let currentCardIndex = 0;
      let cardList = [];
      let isKanjiToEnglishMode = true;
      let allSheetData = [];
      let selectedLevel = null;
      let apiWords = []; // full API words for the level
      let apiGroups = []; // [{ key, items: [...] }]
      let todayList = []; // the computed "today" list from topic + per-day
      let selectedTopicKey = "__ALL__";

      // Grammar
      let allGrammarData = [];
      let currentGrammarData = [];
      let currentGrammarIndex = 0;
      // ---- Robust Speech Synthesis setup ----
      let speechReady = false;
      let loadedVoices = [];
      // NEW: map display header -> original header (exact key in each row)
      const headerKeyMap = Object.create(null);
      let quizItems = []; // { type:'EN→JP'|'JP→EN', question:string|{kanji,hiragana}, correct, options:[...wordObjs], word }
      let quizIndex = 0;

      // Elements
      const passwordUi = document.getElementById("password-ui");
      const passwordInput = document.getElementById("password-input");
      const passwordBtn = document.getElementById("password-btn");
      const levelSelectionUi = document.getElementById("level-selection-ui");
      const studyModeSelectionUi = document.getElementById(
        "study-mode-selection-ui"
      );
      const flashcardInputUi = document.getElementById("flashcard-input-ui");
      const flashcardUi = document.getElementById("flashcard-ui");
      const subHeaderTextElement = document.getElementById("sub-header-text");
      const grammarUi = document.getElementById("grammar-ui");
      const pillRowEl = document.getElementById("selected-pill-row");
      const selectedLevelElement = document.getElementById("selected-level");
      const vocabModeBtn = document.getElementById("vocab-mode-btn");
      const grammarModeBtn = document.getElementById("grammar-mode-btn");
      const backToLevelBtn = document.getElementById("back-to-level-btn");
      const backToModeBtn = document.getElementById("back-to-mode-btn");
      const backFromGrammarBtn = document.getElementById(
        "back-from-grammar-btn"
      );
      const againBtn = document.getElementById("again-btn");
      const gotitBtn = document.getElementById("gotit-btn");
      // const daySelect = document.getElementById("day-select");
      // const loadBtn = document.getElementById("load-btn");
      const generateKanjiToEnglishBtn = document.getElementById(
        "generate-kanji-to-english-btn"
      );
      const generateEnglishToKanjiBtn = document.getElementById(
        "generate-english-to-kanji-btn"
      );
      const flashcardElement = document.getElementById("flashcard");
      const frontTextElement = document.getElementById("front-text");
      const englishBackElement = document.getElementById("english-back");
      const hiraganaBackElement = document.getElementById("hiragana-back");
      const kanjiBackElement = document.getElementById("kanji-back");
      const pronunciationBtn = document.getElementById("pronunciation-btn");
      const cardCountElement = document.getElementById("card-count");
      const nextBtn = document.getElementById("next-btn");
      const previousBtn = document.getElementById("previous-btn");
      const shuffleBtn = document.getElementById("shuffle-btn");
      // Simple inline SVGs per topic (A1 auto-assign). Add/adjust keys as your makeTopicGroups uses.
      const TOPIC_ICONS = {
        People:
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M12 12a5 5 0 1 0-5-5 5 5 0 0 0 5 5Zm0 2c-4.33 0-8 2.17-8 4.5V21h16v-2.5C20 16.17 16.33 14 12 14Z"/></svg>',
        "Food & Drink":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M4 3h2v7a3 3 0 0 1-2 2.83V21H2v-8.17A3 3 0 0 1 0 10V3h2v5h2Zm7-1h10v2h-8v4h7v2h-7v5h-2Z"/></svg>',
        "Nature & Weather":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M6 20a6 6 0 1 1 6-6h6a4 4 0 1 1 0 8H6Z"/></svg>',
        School:
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M12 3 1 9l11 6 9-4.91V17h2V9ZM3 13.74V17l9 5 9-5v-3.26l-9 4.91Z"/></svg>',
        "Work & Business":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M9 3h6a2 2 0 0 1 2 2v2h4v12H3V7h4V5a2 2 0 0 1 2-2Zm0 4h6V5H9Z"/></svg>',
        "Travel & Transport":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M3 13h18l-2 7H5Zm2-8h14l2 7H3Z"/></svg>',
        "Colors & Shapes":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M3 3h8v8H3Zm10 0h8v8h-8Zm0 10h8v8h-8Zm-10 0h8v8H3Z"/></svg>',
        Communication:
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M21 6H3v9h4v4l5-4h9z"/></svg>',
        "Movement & Action":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M13 5a3 3 0 1 1-3 3 3 3 0 0 1 3-3Zm-2 7h4l5 7h-3l-2-3-3 3-3-2 2-5Z"/></svg>',
        Home: '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M12 3 2 12h3v9h6v-6h2v6h6v-9h3Z"/></svg>',
        "Shopping & Money":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M7 7h14l-2 10H7L5 4H2V2h4z"/></svg>',
        "Time & Date":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M12 1a11 11 0 1 0 11 11A11 11 0 0 0 12 1Zm1 6h-2v6l5 3 1-1.73-4-2.27Z"/></svg>',
        "Body & Health":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M12 5a3 3 0 1 0-3-3 3 3 0 0 0 3 3Zm-6 15v-5l3-4 3 2 3-2 3 4v5Z"/></svg>',
        Feelings:
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M12 21s-8-4.44-8-10a5 5 0 0 1 9-3 5 5 0 0 1 9 3c0 5.56-8 10-8 10Z"/></svg>',
        "Change & Condition":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M17 1l4 4-4 4V6H7a4 4 0 0 0 0 8h2v2H7a6 6 0 0 1 0-12h10z"/></svg>',
        "Abstract & Logic":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><circle cx="7" cy="12" r="3"/><circle cx="17" cy="12" r="3"/><path d="M10 12h4"/></svg>',
        "Place & Direction":
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><path d="M12 2a7 7 0 0 0-7 7c0 5 7 13 7 13s7-8 7-13a7 7 0 0 0-7-7Zm0 9a2 2 0 1 1 2-2 2 2 0 0 1-2 2Z"/></svg>',
      };
      function iconForTopic(key) {
        return (
          TOPIC_ICONS[key] ||
          '<svg viewBox="0 0 24 24" fill="currentColor" class="topic-icon"><circle cx="12" cy="12" r="8"/></svg>'
        );
      }

      // Grammar elements
      const grammarPartSelectionEl = document.getElementById(
        "grammar-part-selection"
      );
      const grammarLoadingMessageEl = document.getElementById(
        "grammar-loading-message"
      );
      const grammarFlashcardAppEl = document.getElementById(
        "grammar-flashcard-app"
      );
      const grammarBackButtonEl = document.getElementById(
        "grammar-back-button"
      );
      const grammarFlashcardEl = document.getElementById("grammar-flashcard");
      const grammarFrontContentEl = document.getElementById(
        "grammar-flashcard-front"
      );
      const grammarBackContentEl = document.getElementById(
        "grammar-flashcard-back"
      );
      const grammarStrengthTagEl = document.getElementById(
        "grammar-strength-tag"
      );
      const grammarDirectnessBarEl = document.getElementById(
        "grammar-directness-bar"
      );
      const grammarPolitenessBarEl = document.getElementById(
        "grammar-politeness-bar"
      );
      const grammarNameEl = document.getElementById("grammar-name");
      const grammarMeaningEl = document.getElementById("grammar-meaning");
      const grammarFormEl = document.getElementById("grammar-form");
      const grammarJapaneseExampleEl = document.getElementById(
        "grammar-japanese-example"
      );
      const grammarKeyPointEl = document.getElementById("grammar-key-point");
      const grammarNextButtonEl = document.getElementById(
        "grammar-next-button"
      );
      const grammarPrevButtonEl = document.getElementById(
        "grammar-prev-button"
      );
      // const topicSelect = document.getElementById("topic-select");
      const perDayInput = document.getElementById("per-day-input");
      const useOrganizedCache = document.getElementById("use-organized-cache");
      // ---------- TOPIC RULES (semantic, keyword-based) ----------
      const TOPIC_RULES = [
        {
          key: "People",
          kw: [
            /person|people|man|woman|friend|family|child|teacher|student|customer/i,
            /者|人/,
          ],
          weight: 1,
        },
        {
          key: "Body & Health",
          kw: [
            /body|hand|head|eye|ear|mouth|health|sick|hospital|medicine|pain|injur/i,
            /体|病|院|薬/,
          ],
          weight: 1,
        },
        {
          key: "Feelings",
          kw: [
            /happy|glad|sad|angry|afraid|scared|embarrass|envious|lonely|fun|boring/i,
          ],
          weight: 1,
        },
        {
          key: "Food & Drink",
          kw: [
            /eat|drink|meal|rice|bread|meat|fish|vegetable|fruit|sugar|salt|taste|cook|boil|grill/i,
            /食|飲|味|鍋|焼|煮|揚/,
          ],
          weight: 1,
        },
        {
          key: "Home",
          kw: [
            /house|home|room|kitchen|bath|toilet|door|window|clean|tidy|furniture/i,
            /家|室|台|風呂|窓|戸/,
          ],
          weight: 1,
        },
        {
          key: "School",
          kw: [
            /school|class|study|learn|teacher|student|exam|test|practice|homework/i,
            /学|校|習|練/,
          ],
          weight: 1,
        },
        {
          key: "Work & Business",
          kw: [
            /work|job|office|company|boss|salary|plan|report|confirm|contact|introduce|guide/i,
            /社|業|課|部|係/,
          ],
          weight: 1,
        },
        {
          key: "Travel & Transport",
          kw: [
            /go|come|return|travel|trip|car|train|bus|drive|carry|transport|ticket/i,
            /行|来|帰|車|電車|駅/,
          ],
          weight: 1,
        },
        {
          key: "Shopping & Money",
          kw: [
            /buy|sell|shop|store|price|expensive|cheap|pay|money|bill|receipt|card|reserve|book/i,
            /買|売|店|円|札/,
          ],
          weight: 1,
        },
        {
          key: "Time & Date",
          kw: [
            /day|week|month|year|morning|night|late|early|fast|slow|time|schedule|plan/i,
            /時|日|週|月|年/,
          ],
          weight: 1,
        },
        {
          key: "Nature & Weather",
          kw: [
            /weather|hot|cold|cool|warm|rain|snow|wind|sea|mountain|river|forest|animal/i,
            /天|気|山|川|海|風|雨|雪/,
          ],
          weight: 1,
        },
        {
          key: "Place & Direction",
          kw: [
            /place|area|wide|narrow|near|far|left|right|front|back|inside|outside/i,
            /場|所|内|外|上|下|前|後|近|遠/,
          ],
          weight: 1,
        },
        {
          key: "Colors & Shapes",
          kw: [
            /red|blue|yellow|black|white|brown|color|round|square|shape|thick|thin/i,
          ],
          weight: 1,
        },
        {
          key: "Quantity & Degree",
          kw: [
            /many|few|increase|decrease|more|less|very|quite|enough|too|too much/i,
            /増|減|多|少/,
          ],
          weight: 1,
        },
        {
          key: "Change & Condition",
          kw: [
            /change|become|remain|decide|decided|break|fix|cool|hot|open|close/i,
            /変|決|壊|冷|開|閉/,
          ],
          weight: 1,
        },
        {
          key: "Communication",
          kw: [
            /say|speak|talk|listen|hear|read|write|explain|translate|interpret|contact|promise/i,
            /話|聞|読|書|訳|連絡|約束/,
          ],
          weight: 1,
        },
        {
          key: "Movement & Action",
          kw: [
            /stand|sit|walk|run|swim|fly|play|move|pick|drop|throw|help|protect/i,
            /動|歩|走|泳|飛|助|守/,
          ],
          weight: 1,
        },
        {
          key: "Abstract & Logic",
          kw: [
            /true|false|real|necessary|unnecessary|simple|complicated|clear|vague|accurate/i,
          ],
          weight: 1,
        },
      ];
      // cache constants (organized)
      const ORG_CACHE_KEY = (lvl) => `jlpt-api-org-v2-${levelStrToNum(lvl)}`;
      const ORG_CACHE_DAYS = 7;
      // ---------- SRS: state, keys, intervals ----------
      const SRS_KEY = (lvl) => `jlpt-srs-v1-${levelStrToNum(lvl)}`; // per-level progress

      const SRS_INTERVALS_DAYS = [1, 3, 7, 14, 30]; // 5 steps
      const REVIEW_PORTION = 0.25; // 25% review / 75% new

      // word id (stable across sessions). API doesn’t provide ids, so compose one:
      // const wid = (w) => `${w.kanji}｜${w.english}`;
      function wid(w) {
        if (!w) return "";
        const k = (w.kanji ?? w.word ?? "").trim();
        const h = (w.hiragana ?? w.kana ?? w.reading ?? "").trim();
        const e = (w.english ?? w.meaning ?? "").trim();
        return `${k}｜${h}｜${e}`.trim();
      }
      // Init
      document.addEventListener("DOMContentLoaded", () => {
        if (localStorage.getItem(passwordCacheKey) === correctPassword) {
          showLevelSelection();
        } else {
          showPasswordScreen();
        }
      });

      // normalize helper
      function norm(s) {
        return (s || "").toString().toLowerCase();
      }
      function pickN(arr, n, seedStr = "") {
        if (n <= 0 || !arr.length) return [];
        // simple seeded rotate
        let h = 2166136261 >>> 0;
        for (let i = 0; i < seedStr.length; i++) {
          h ^= seedStr.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        const start = h % arr.length;
        const out = [];
        for (let i = 0; i < Math.min(n, arr.length); i++) {
          out.push(arr[(start + i) % arr.length]);
        }
        return out;
      }

      function buildQuizFromToday() {
        // Normalize sources
        const today = normalizeList(cardList);
        if (!today.length) {
          showModal("No quiz", "No valid words were found for today.");
          return;
        }

        // Use full cached pool for distractors; fall back to today if needed
        const poolAllRaw = apiGroups?.flatMap((g) => g.items) ?? [];
        let poolAll = normalizeList(poolAllRaw);
        if (!poolAll.length) poolAll = today.slice();

        // De-dup (by wid) so we don’t get duplicate options
        const seen = new Set();
        poolAll = poolAll.filter((w) => {
          const id = wid(w);
          if (!id || seen.has(id)) return false;
          seen.add(id);
          return true;
        });

        // Deterministic-ish order per day for variety without surprises
        const seed =
          new Date().toISOString().slice(0, 10) + "|" + (selectedLevel || "N3");
        const ordered = pickN(today, today.length, seed);

        const half = Math.max(1, Math.floor(ordered.length / 2));
        const firstHalf = ordered.slice(0, half); // EN→JP
        const secondHalf = ordered.slice(half); // JP→EN

        const mkOptions = (answer, howMany = 4, seedKey = "") => {
          // Distractors from pool excluding the answer
          const answerId = wid(answer);
          const candidates = poolAll.filter((w) => wid(w) !== answerId);
          // If not enough pool, just use today minus answer
          const base = candidates.length
            ? candidates
            : today.filter((w) => wid(w) !== answerId);
          const picked = pickN(base, howMany - 1, seed + seedKey + answerId);
          // Build full list and shuffle
          const all = normalizeList([...picked, answer]).filter(Boolean);
          // ensure exactly 'howMany' items (backfill if needed)
          if (all.length < howMany) {
            const extra = base.filter(
              (w) => !all.some((x) => wid(x) === wid(w))
            );
            all.push(
              ...normalizeList(
                pickN(extra, howMany - all.length, seed + seedKey + "extra")
              )
            );
          }
          // final clamp
          const options = all.slice(0, howMany);
          options.sort(() => Math.random() - 0.5);
          return options;
        };

        const items = [];

        // EN→JP (prompt English, options show JP)
        firstHalf.forEach((word) => {
          if (!word) return;
          const en = getEnglish(word);
          // skip if missing English or missing JP surface
          if (!en) return;
          const options = mkOptions(word, 4, "ENJP");
          items.push({
            type: "EN→JP",
            question: en,
            options,
            correct: word,
            word,
          });
        });

        // JP→EN (prompt JP, options show English)
        secondHalf.forEach((word) => {
          if (!word) return;
          const jpK = getKanji(word);
          const jpF = getKana(word);
          const en = getEnglish(word);
          // require at least some JP and EN to make a valid QA
          if (!en || (!jpK && !jpF)) return;
          const options = mkOptions(word, 4, "JPEN");
          items.push({
            type: "JP→EN",
            question: { kanji: jpK, hiragana: jpF },
            options,
            correct: word,
            word,
          });
        });

        // Final guard
        quizItems = items.filter((q) => q?.correct && q?.options?.length === 4);
        if (!quizItems.length) {
          showModal(
            "No quiz",
            "Not enough valid items to generate a quiz. Try loading a different topic or more words."
          );
          return;
        }

        quizIndex = 0;

        // switch UI
        flashcardUi.classList.add("hidden");
        document.getElementById("quiz-ui").classList.remove("hidden");

        renderQuizQuestion();
      }

      // score a word against topics
      function classifyWord(wordObj) {
        const en = norm(wordObj.english);
        const kj = wordObj.kanji || "";
        let best = { key: "Other", score: 0 };
        for (const topic of TOPIC_RULES) {
          let score = 0;
          for (const r of topic.kw) {
            if (typeof r === "object" && r.test) {
              if (r.source.charCodeAt(0) > 255) {
                // rough: kanji regex
                if (r.test(kj)) score += topic.weight;
              } else {
                if (r.test(en)) score += topic.weight;
              }
            }
          }
          if (score > best.score) best = { key: topic.key, score };
        }
        return best.score > 0 ? best.key : "Other";
      }
      // load/save SRS progress
      function loadSRS(levelStr) {
        try {
          return JSON.parse(localStorage.getItem(SRS_KEY(levelStr)) || "{}");
        } catch {
          return {};
        }
      }
      function saveSRS(levelStr, srs) {
        localStorage.setItem(SRS_KEY(levelStr), JSON.stringify(srs));
      }

      // Stage color map
      const STAGE_COLORS = {
        new: "bg-rose-500",
        d1: "bg-amber-500",
        d3: "bg-yellow-500",
        d7: "bg-sky-500",
        d14: "bg-indigo-500",
        d30: "bg-emerald-500",
      };

      function stageKeyFromStep(step) {
        if (step < 0) return "new";
        return ["d1", "d3", "d7", "d14", "d30"][Math.min(step, 4)];
      }

      // Compute counts for each group/topic by SRS stage
      function computeTopicProgress(levelStr, groups) {
        const srs = loadSRS(levelStr);
        return groups.map((g) => {
          const counts = {
            new: 0,
            d1: 0,
            d3: 0,
            d7: 0,
            d14: 0,
            d30: 0,
            total: g.items.length,
          };
          g.items.forEach((w) => {
            const id = wid(w);
            const rec = srs[id];
            const key = rec ? stageKeyFromStep(rec.step ?? -1) : "new";
            counts[key] += 1;
          });
          return { key: g.key, counts };
        });
      }

      const selectedTopics = new Set(); // multi-select state
      const topicGridEl = document.getElementById("topic-progress-grid");

      function renderTopicProgressGrid(levelStr, groups) {
        if (!topicGridEl) return;
        const rows = computeTopicProgress(levelStr, groups);
        topicGridEl.innerHTML = "";

        rows.forEach((row) => {
          const { key, counts } = row;
          const total = Math.max(1, counts.total);
          const pct = {
            new: (counts.new / total) * 100,
            d1: (counts.d1 / total) * 100,
            d3: (counts.d3 / total) * 100,
            d7: (counts.d7 / total) * 100,
            d14: (counts.d14 / total) * 100,
            d30: (counts.d30 / total) * 100,
          };

          const card = document.createElement("button");
          card.type = "button";
          card.className = `w-full rounded-xl p-3 bg-gray-800 hover:bg-gray-750 text-left flex flex-col gap-2 topic-card ${
            selectedTopics.has(key) ? "selected" : ""
          }`;

          card.innerHTML = `
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-3">
          <span class="text-gray-300">${iconForTopic(key)}</span>
          <div class="font-semibold text-gray-100">${key}</div>
        </div>
        <div class="text-[11px] text-gray-400">${counts.total} words</div>
      </div>
      <div class="w-full h-3 rounded overflow-hidden flex">
        <div class="bg-rose-500"   style="width:${pct.new}%;"></div>
        <div class="bg-amber-500"  style="width:${pct.d1}%;"></div>
        <div class="bg-yellow-500" style="width:${pct.d3}%;"></div>
        <div class="bg-sky-500"    style="width:${pct.d7}%;"></div>
        <div class="bg-indigo-500" style="width:${pct.d14}%;"></div>
        <div class="bg-emerald-500"style="width:${pct.d30}%;"></div>
      </div>
      <div class="text-[11px] text-gray-400">
        New ${Math.round(pct.new)}% · 1d ${Math.round(
            pct.d1
          )}% · 3d ${Math.round(pct.d3)}% · 7d ${Math.round(
            pct.d7
          )}% · 14d ${Math.round(pct.d14)}% · 30d ${Math.round(pct.d30)}%
      </div>
    `;

          card.addEventListener("click", () => {
            if (selectedTopics.has(key)) selectedTopics.delete(key);
            else selectedTopics.add(key);
            renderTopicProgressGrid(levelStr, groups);
            renderSelectedPills(groups); // update pills
          });

          topicGridEl.appendChild(card);
        });

        // also update pills whenever we (re)render the grid
        renderSelectedPills(groups);
      }

      function renderSelectedPills(groups) {
        if (!pillRowEl) return;
        pillRowEl.innerHTML = "";

        const pillBase =
          "inline-flex items-center gap-1 px-2 py-0.5 rounded-full " +
          "text-[11px] leading-4 font-medium text-white " +
          "bg-gradient-to-r ring-1 ring-white/10 shadow-sm";

        // If nothing selected, show “All topics”
        if (selectedTopics.size === 0) {
          const p = document.createElement("span");
          p.className = `${pillBase} from-emerald-600 to-cyan-600`;
          p.textContent = "All topics";
          pillRowEl.appendChild(p);
          return;
        }

        const set = new Set(selectedTopics);
        const visible = groups.filter((g) => set.has(g.key)).map((g) => g.key);

        const gradients = [
          ["from-emerald-600", "to-cyan-600"],
          ["from-indigo-600", "to-violet-600"],
          ["from-rose-600", "to-orange-600"],
          ["from-sky-600", "to-blue-600"],
          ["from-amber-600", "to-yellow-600"],
          ["from-teal-600", "to-lime-600"],
        ];

        const maxToShow = 3;

        visible.slice(0, maxToShow).forEach((k, i) => {
          const [fromC, toC] = gradients[i % gradients.length];
          const p = document.createElement("span");
          p.className = `${pillBase} ${fromC} ${toC}`;
          p.textContent = k;
          pillRowEl.appendChild(p);
        });

        if (visible.length > maxToShow) {
          const more = document.createElement("span");
          more.className = `${pillBase} from-gray-600 to-gray-500`;
          more.textContent = `+${visible.length - maxToShow} more`;
          pillRowEl.appendChild(more);
        }
      }

      // upsert record
      function ensureCard(srs, id) {
        if (!srs[id]) srs[id] = { due: 0, step: -1, last: 0 }; // step -1 = never studied (new)
        return srs[id];
      }
      function nowUTCms() {
        return Date.now();
      }
      function addDays(ms, d) {
        return ms + d * 24 * 60 * 60 * 1000;
      }
      function isDue(rec) {
        return rec.due <= nowUTCms();
      }
      // wait for voices to load (Chrome/Safari can be late)
      function loadVoicesOnce() {
        return new Promise((resolve) => {
          const tryLoad = () => {
            loadedVoices = window.speechSynthesis.getVoices() || [];
            if (loadedVoices.length) {
              speechReady = true;
              resolve(loadedVoices);
              return true;
            }
            return false;
          };
          if (tryLoad()) return;

          // event + timeouts as fallback (iOS often needs both)
          const onChange = () => {
            if (tryLoad()) {
              window.speechSynthesis.removeEventListener(
                "voiceschanged",
                onChange
              );
            }
          };
          window.speechSynthesis.addEventListener("voiceschanged", onChange);

          // last-resort polling (2s)
          let tries = 0;
          const id = setInterval(() => {
            tries++;
            if (tryLoad() || tries > 10) {
              clearInterval(id);
              window.speechSynthesis.removeEventListener(
                "voiceschanged",
                onChange
              );
              resolve(loadedVoices);
            }
          }, 200);
        });
      }

      function pickJapaneseVoice() {
        if (!loadedVoices?.length) return null;
        // Best: exact ja-JP
        let v = loadedVoices.find((v) => /ja/i.test(v.lang));
        if (v) return v;
        // Some engines mark Japanese as 'ja' only
        v = loadedVoices.find((v) => v.lang && v.lang.toLowerCase() === "ja");
        if (v) return v;
        // Fallback: any local voice (still works but accent will be off)
        return (
          loadedVoices.find((v) => v.localService) || loadedVoices[0] || null
        );
      }

      // optional: chunk very long text (prevents some engines from failing)
      function chunk(text, size = 180) {
        if (!text || text.length <= size) return [text];
        const parts = [];
        let i = 0;
        while (i < text.length) {
          parts.push(text.slice(i, i + size));
          i += size;
        }
        return parts;
      }
      // schedule after an answer
      function scheduleNext(rec, wasCorrect) {
        const t = nowUTCms();
        rec.last = t;
        if (!wasCorrect) {
          rec.step = Math.max(-1, rec.step - 1); // penalize
          const days = SRS_INTERVALS_DAYS[0]; // come back soon
          rec.due = addDays(t, days);
          return;
        }
        rec.step = Math.min(rec.step + 1, SRS_INTERVALS_DAYS.length - 1);
        const days = SRS_INTERVALS_DAYS[Math.max(rec.step, 0)];
        rec.due = addDays(t, days);
      }

      // compute today’s set: mix due reviews + new
      function computeTodaySet(levelStr, groups, topicKey, perDay) {
        const srs = loadSRS(levelStr);
        // build pool
        const pool =
          topicKey && topicKey !== "__ALL__"
            ? groups.find((g) => g.key === topicKey)?.items || []
            : groups.flatMap((g) => g.items);

        // separate due reviews vs new
        const due = [];
        const fresh = [];
        for (const w of pool) {
          const id = wid(w);
          const rec = ensureCard(srs, id);
          if (rec.step >= 0 && isDue(rec)) due.push(w); // learned before & due
          if (rec.step < 0) fresh.push(w); // never studied
        }

        // target counts
        const wantReview = Math.floor(perDay * REVIEW_PORTION);
        const wantNew = Math.max(0, perDay - wantReview);

        // slice deterministically for the day
        const seed = `${new Date().toISOString().slice(0, 10)}|${
          topicKey || "__ALL__"
        }|${levelStr}`;
        function pick(arr, n) {
          if (!arr.length || n <= 0) return [];
          const start =
            (function stableHash(s) {
              let h = 2166136261 >>> 0;
              for (let i = 0; i < s.length; i++) {
                h ^= s.charCodeAt(i);
                h = Math.imul(h, 16777619);
              }
              return h >>> 0;
            })(seed) % arr.length;
          const out = [];
          for (let i = 0; i < Math.min(n, arr.length); i++) {
            out.push(arr[(start + i) % arr.length]);
          }
          return out;
        }

        const reviews = pick(due, wantReview);
        const news = pick(fresh, wantNew);

        return {
          list: [...reviews, ...news],
          reviewCount: reviews.length,
          newCount: news.length,
        };
      }
      // make semantic topic groups
      function makeTopicGroups(words) {
        const map = new Map();
        for (const w of words) {
          const t = classifyWord(w);
          if (!map.has(t)) map.set(t, []);
          map.get(t).push(w);
        }
        // order by size desc, with "Other" last
        const entries = [...map.entries()];
        entries.sort((a, b) => {
          if (a[0] === "Other" && b[0] !== "Other") return 1;
          if (b[0] === "Other" && a[0] !== "Other") return -1;
          return b[1].length - a[1].length;
        });
        return entries.map(([key, items]) => ({ key, items }));
      }

      // fast kanji detection and grouping key
      const isKanji = (ch) => /[\u4e00-\u9faf\u3400-\u4dbf]/.test(ch);
      const firstKey = (str) => {
        if (!str) return "その他";
        for (const ch of String(str)) {
          if (/\s/.test(ch)) continue;
          return isKanji(ch) ? `漢:${ch}` : `仮:${ch}`;
        }
        return "その他";
      };

      // make topic groups (by first kanji/kana); sorted biggest first
      function makeGroups(words) {
        const map = new Map();
        for (const w of words) {
          const k = firstKey(w.kanji || w.hiragana || "");
          if (!map.has(k)) map.set(k, []);
          map.get(k).push(w);
        }
        return [...map.entries()]
          .sort((a, b) => b[1].length - a[1].length)
          .map(([key, items]) => ({ key, items }));
      }

      // deterministic daily slicing (stable by date + topic + level)
      function stableHash(str) {
        let h = 2166136261 >>> 0;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return h >>> 0;
      }
      const todayKey = () => {
        const d = new Date(); // UTC to keep it stable regardless of user tz
        return `${d.getUTCFullYear()}-${d.getUTCMonth() + 1}-${d.getUTCDate()}`;
      };
      function pickTodaySlice(items, perDay, seedStr) {
        if (!items.length) return [];
        const start = stableHash(seedStr) % items.length;
        const out = [];
        for (let i = 0; i < Math.min(perDay, items.length); i++) {
          out.push(items[(start + i) % items.length]);
        }
        return out;
      }
      function computeTodayList(levelStr) {
        const perDay = parseInt(perDayInput?.value || "20", 10) || 20;
        let pool = [];
        if (selectedTopicKey && selectedTopicKey !== "__ALL__") {
          const g = apiGroups.find((x) => x.key === selectedTopicKey);
          pool = g ? g.items : [];
        } else {
          pool = apiGroups.flatMap((g) => g.items);
        }
        const seed = `${todayKey()}|${selectedTopicKey}|${levelStr}`;
        todayList = pickTodaySlice(pool, perDay, seed);
      }
      // ===== 1) New: load vocab from JLPT API by level (with grouping + organized cache) =====

      async function loadVocabFromApi(selectedLevel) {
        // 1) Try organized cache
        try {
          const raw = localStorage.getItem(ORG_CACHE_KEY(selectedLevel));
          if (raw) {
            const { t, words: cachedWords, groups } = JSON.parse(raw);
            const ageDays = (Date.now() - (t || 0)) / (1000 * 60 * 60 * 24);
            if (
              t &&
              ageDays <= 7 &&
              Array.isArray(cachedWords) &&
              Array.isArray(groups)
            ) {
              apiWords = cachedWords;
              apiGroups = groups;

              // RENDER THE GRID EVEN ON CACHE HIT ✅
              renderTopicProgressGrid(selectedLevel, apiGroups);

              // (remove this if you deleted the select)
              // fillTopicSelect(apiGroups);

              // Optional: toast so you know it ran
              showToast(`Loaded cached vocab (${apiWords.length})`);
              return;
            }
          }
        } catch (e) {
          console.warn("Cache read failed", e);
        }

        // 2) Fresh fetch
        const res = await fetch(
          `${JLPT_API_BASE}/api/words/all?level=${levelStrToNum(
            selectedLevel
          )}&cb=${Date.now()}`
        );
        if (!res.ok) {
          showModal("API Error", `HTTP ${res.status}`);
          return;
        }
        const data = await res.json();

        apiWords = normalizeList(
          data.map((item) => ({
            kanji: item.word,
            hiragana: item.furigana ?? item.kana ?? item.reading,
            english: item.meaning,
          }))
        );

        // Safety check
        if (!apiWords.length) {
          showModal(
            "No words",
            `API returned 0 normalized items for JLPT ${selectedLevel}`
          );
          return;
        }

        // Semantic grouping (makeTopicGroups must be defined)
        apiGroups = makeTopicGroups(apiWords);
        // RENDER THE GRID ON FRESH FETCH ✅
        renderTopicProgressGrid(selectedLevel, apiGroups); // draw cards
        renderSelectedPills(apiGroups); // draw pills

        // Save organized cache (best-effort)
        try {
          localStorage.setItem(
            ORG_CACHE_KEY(selectedLevel),
            JSON.stringify({
              t: Date.now(),
              words: apiWords,
              groups: apiGroups,
            })
          );
        } catch (e) {
          console.warn("Cache write failed", e);
        }

        showToast(`Loaded vocab (${apiWords.length})`);
      }

      function generateCards(mode) {
        const perDay =
          parseInt(
            document.getElementById("per-day-input")?.value || "20",
            10
          ) || 20;

        // topicKeys: selected set OR all topics
        const topicKeys = selectedTopics.size
          ? [...selectedTopics]
          : ["__ALL__"];

        // compute today’s set with multi-topic support
        const { list, reviewCount, newCount } = computeTodaySetMulti(
          selectedLevel,
          apiGroups,
          topicKeys,
          perDay
        );

        if (!list.length) {
          showModal(
            "All caught up!",
            "No due reviews and no new words left today for the selected topics."
          );
          return;
        }

        cardList = normalizeList(list);
        if (!cardList.length) {
          showModal(
            "No cards",
            "Nothing to study for the chosen topics today."
          );
          return;
        }
        currentCardIndex = 0;
        isKanjiToEnglishMode = mode === "kanji-to-english";
        updateCard();

        flashcardInputUi.classList.add("hidden");
        flashcardUi.classList.remove("hidden");

        const topicsLabel =
          topicKeys[0] === "__ALL__" ? "All topics" : topicKeys.join(", ");
        subHeaderTextElement.textContent = `JLPT ${selectedLevel} — ${topicsLabel} · ${reviewCount} review · ${newCount} new`;
      }

      function computeTodaySetMulti(levelStr, groups, topicKeys, perDay) {
        // reuse your SRS-based compute logic
        const srs = loadSRS(levelStr);

        // gather pool for selected topics
        let pool = [];
        if (topicKeys.length === 1 && topicKeys[0] === "__ALL__") {
          pool = groups.flatMap((g) => g.items);
        } else {
          const set = new Set(topicKeys);
          pool = groups.filter((g) => set.has(g.key)).flatMap((g) => g.items);
        }

        // split due vs new
        const due = [],
          fresh = [];
        for (const w of pool) {
          const id = wid(w);
          const rec = ensureCard(srs, id);
          if (rec.step >= 0 && isDue(rec)) due.push(w);
          if (rec.step < 0) fresh.push(w);
        }

        const wantReview = Math.floor(perDay * 0.25);
        const wantNew = Math.max(0, perDay - wantReview);

        // deterministic pick
        const seed = `${new Date().toISOString().slice(0, 10)}|${topicKeys.join(
          "+"
        )}|${levelStr}`;
        const pick = (arr, n) => {
          if (!arr.length || n <= 0) return [];
          let h = 2166136261 >>> 0;
          for (let i = 0; i < seed.length; i++) {
            h ^= seed.charCodeAt(i);
            h = Math.imul(h, 16777619);
          }
          const start = h % arr.length;
          const out = [];
          for (let i = 0; i < Math.min(n, arr.length); i++) {
            out.push(arr[(start + i) % arr.length]);
          }
          return out;
        };

        const reviews = pick(due, wantReview);
        const news = pick(fresh, wantNew);
        const list = normalizeList([...reviews, ...news]);
        return { list, reviewCount: reviews.length, newCount: news.length };
      }

      function updateCard() {
        // const currentCard = cardList[currentCardIndex];
        const currentCard = cardList[currentCardIndex];
        const srs = loadSRS(selectedLevel);
        const rec = srs[wid(currentCard)];

        if (!Array.isArray(cardList) || cardList.length === 0) {
          console.warn("updateCard(): empty cardList", cardList);
          return;
        }
        if (currentCardIndex < 0 || currentCardIndex >= cardList.length) {
          currentCardIndex = 0;
        }

        if (!currentCard) {
          console.warn(
            "updateCard(): currentCard is falsy at",
            currentCardIndex
          );
          return;
        }

        if (isKanjiToEnglishMode) {
          frontTextElement.textContent = currentCard.kanji;
          frontTextElement.classList.remove("front-english");
          englishBackElement.textContent = currentCard.english;
          hiraganaBackElement.textContent = currentCard.hiragana;
          kanjiBackElement.textContent = "";
        } else {
          frontTextElement.textContent = currentCard.english;
          frontTextElement.classList.add("front-english");
          kanjiBackElement.textContent = currentCard.kanji;
          hiraganaBackElement.textContent = currentCard.hiragana;
          englishBackElement.textContent = "";
        }

        flashcardElement.classList.remove("is-flipped");
        cardCountElement.textContent = `${currentCardIndex + 1} / ${
          cardList.length
        }`;

        if (rec && rec.step >= 0) {
          cardCountElement.textContent = `${currentCardIndex + 1} / ${
            cardList.length
          } · due: ${new Date(rec.due).toLocaleDateString()}`;
        } else {
          cardCountElement.textContent = `${currentCardIndex + 1} / ${
            cardList.length
          }`;
        }
      }

      function flipCard() {
        flashcardElement.classList.toggle("is-flipped");
      }
      function nextCard() {
        if (currentCardIndex === cardList.length - 1) {
          buildQuizFromToday();
          return;
        }
        currentCardIndex = (currentCardIndex + 1) % cardList.length;
        updateCard();
      }
      function previousCard() {
        currentCardIndex =
          (currentCardIndex - 1 + cardList.length) % cardList.length;
        updateCard();
      }
      function shuffleCards() {
        for (let i = cardList.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [cardList[i], cardList[j]] = [cardList[j], cardList[i]];
        }
        currentCardIndex = 0;
        updateCard();
        shuffleBtn.textContent = "Shuffled!";
        setTimeout(() => {
          shuffleBtn.innerHTML = '<i class="fas fa-random"></i>';
        }, 1000);
      }

      async function speakWord(event) {
        if (event) event.stopPropagation();

        if (!("speechSynthesis" in window)) {
          showModal(
            "Warning",
            "Speech synthesis is not supported in this browser."
          );
          return;
        }

        // Must be on https and after a user gesture (this click)
        // Prepare voices (once per session)
        await loadVoicesOnce();

        const currentCard = cardList[currentCardIndex];
        if (!currentCard) return;

        // What to speak
        const textToSpeak = isKanjiToEnglishMode
          ? currentCard.hiragana || currentCard.kanji || ""
          : `${currentCard.kanji || ""} ${currentCard.hiragana || ""}`.trim();

        if (!textToSpeak) return;

        // Cancel any ongoing speech cleanly
        try {
          window.speechSynthesis.cancel();
        } catch {}

        const voice = pickJapaneseVoice();

        // Some engines fail silently; show a pulse while speaking
        pronunciationBtn.innerHTML =
          '<i class="fas fa-volume-up animate-pulse"></i>';

        const speakOne = (phrase) =>
          new Promise((resolve, reject) => {
            const utt = new SpeechSynthesisUtterance(phrase);
            if (voice) utt.voice = voice;
            utt.lang = voice?.lang || "ja-JP";
            utt.rate = 1.0; // tweak if you want slower/faster
            utt.pitch = 1.0;
            utt.onend = () => resolve();
            utt.onerror = (e) => reject(e.error || e);
            try {
              window.speechSynthesis.speak(utt);
            } catch (e) {
              reject(e);
            }
          });

        try {
          // For longer strings, speak in chunks
          const parts = chunk(textToSpeak, 140);
          for (const p of parts) {
            // Some engines require a tiny gap between chunks
            // eslint-disable-next-line no-await-in-loop
            await speakOne(p);
          }
        } catch (e) {
          console.error("Speech synthesis error:", e);
          // Give a clearer hint
          const hint =
            location.protocol !== "https:" ? " (tip: use https)" : "";
          showModal(
            "Error",
            "Speech synthesis failed. Please try again" + hint + "."
          );
        } finally {
          pronunciationBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
        }
      }

      function renderQuizQuestion() {
        const q = quizItems[quizIndex];
        if (!q) return;

        const total = quizItems.length;
        document.getElementById("quiz-progress").textContent = `Question ${
          quizIndex + 1
        } / ${total}`;

        const promptEl = document.getElementById("quiz-prompt");
        const choicesEl = document.getElementById("quiz-choices");
        const feedbackEl = document.getElementById("quiz-feedback");

        feedbackEl.textContent = "";
        choicesEl.innerHTML = "";

        if (q.type === "EN→JP") {
          promptEl.textContent = `What is the word for “${q.question}”?`;
          q.options.forEach((opt) => {
            const btn = document.createElement("button");
            btn.className = "choice-btn";
            btn.innerHTML = `
        <div class="choice-jp-kana">${getKana(opt)}</div>
        <div class="choice-jp-kanji">${getKanji(opt)}</div>
      `;
            btn.addEventListener("click", () => onAnswer(opt, q));
            choicesEl.appendChild(btn);
          });
        } else {
          // JP→EN
          const { kanji, hiragana } = q.question || {};
          promptEl.innerHTML = `
      <div class="choice-jp-kana mb-1">${hiragana || ""}</div>
      <div class="choice-jp-kanji">${kanji || ""}</div>
      <div class="text-sm mt-2 text-gray-400">Choose the correct meaning</div>
    `;
          q.options.forEach((opt) => {
            const btn = document.createElement("button");
            btn.className = "choice-btn";
            btn.innerHTML = `<div class="choice-en">${getEnglish(opt)}</div>`;
            btn.addEventListener("click", () => onAnswer(opt, q));
            choicesEl.appendChild(btn);
          });
        }

        document.getElementById("quiz-prev-btn").disabled = quizIndex === 0;
        document.getElementById("quiz-next-btn").textContent =
          quizIndex === total - 1 ? "Finish" : "Next";
      }

      function onAnswer(selected, q) {
        const choices = Array.from(
          document.querySelectorAll("#quiz-choices .choice-btn")
        );
        // lock buttons
        choices.forEach((c) => (c.disabled = true));

        const srs = loadSRS(selectedLevel);
        const idCorrect = wid(q.correct);
        const rec = ensureCard(srs, idCorrect);

        const isCorrect = selected === q.correct;

        // decorate UI
        choices.forEach((btn) => {
          const shows = btn.textContent.replace(/\s+/g, " ").trim();
          const match =
            (q.type === "EN→JP" && shows.includes(q.correct.kanji)) ||
            (q.type === "JP→EN" && shows === (q.correct.english || "").trim());
          if (match) btn.classList.add("correct");
        });
        // mark wrong one user clicked
        const idx = choices.findIndex((c) => c === event?.currentTarget); // not reliable across closures; fallback:
        if (!isCorrect) {
          // best effort: add .wrong to the first non-correct that matches selected content
          choices.some((btn) => {
            const txt = btn.textContent.replace(/\s+/g, " ").trim();
            const match =
              (q.type === "EN→JP" && txt.includes(selected.kanji || "")) ||
              (q.type === "JP→EN" && txt === (selected.english || "").trim());
            if (match) {
              btn.classList.add("wrong");
              return true;
            }
            return false;
          });
        }

        // SRS rule
        if (isCorrect) {
          // promote one step + schedule according to your ladder (1d,3d,7d,14d,30d)
          promote(rec); // you already have promote/ensureCard/saveSRS in your SRS helpers
          saveSRS(selectedLevel, srs);
          document.getElementById("quiz-feedback").textContent =
            "✅ Correct! Promoted to next interval.";
        } else {
          // move it to tomorrow: keep step the same, but nextDue = now + 1 day
          rec.next = Date.now() + 24 * 60 * 60 * 1000;
          saveSRS(selectedLevel, srs);
          document.getElementById("quiz-feedback").textContent =
            "❌ Not quite. We’ll revisit this word tomorrow.";
        }
      }
      // Coerce any incoming shape into {kanji, hiragana, english}
      function normalizeWord(raw) {
        if (!raw) return null;
        const kanji = raw.kanji ?? raw.word ?? raw.jp ?? raw.term ?? "";
        const hiragana =
          raw.hiragana ?? raw.kana ?? raw.reading ?? raw.ruby ?? "";
        const english = raw.english ?? raw.meaning ?? raw.gloss ?? raw.en ?? "";

        // Drop totally empty items
        if (!kanji && !hiragana) return null;
        if (!english) return null;

        return {
          kanji: String(kanji).trim(),
          hiragana: String(hiragana).trim(),
          english: String(english).trim(),
        };
      }

      // Guard for lists
      function normalizeList(arr) {
        if (!Array.isArray(arr)) return [];
        return arr.map(normalizeWord).filter(Boolean);
      }

      // ===== Grammar (CSV) =====
      async function fetchGrammarData() {
        grammarLoadingMessageEl.style.display = "block";
        grammarLoadingMessageEl.textContent = "Loading grammar data...";
        allGrammarData = [];

        const urlWithCb = n3grammarUrl + "&cb=" + Date.now();

        Papa.parse(urlWithCb, {
          download: true,
          header: false,
          skipEmptyLines: true,
          complete: function (results) {
            const firstRow = results.data.length > 0 ? results.data[0] : [];
            const isHeaderRowPresent =
              firstRow.length > 0 &&
              String(firstRow[0]).trim().toLowerCase() === "part 1";
            const rowToProcess = isHeaderRowPresent
              ? results.data.length > 1
                ? results.data[1]
                : []
              : firstRow;

            rowToProcess.forEach((cell) => {
              const jsonString = cell ? String(cell).trim() : "";
              if (!jsonString) return;
              try {
                const partData = JSON.parse(jsonString);
                allGrammarData.push(partData);
              } catch (e) {
                console.error("JSON parse error:", e, jsonString);
              }
            });

            if (allGrammarData.length > 0) {
              renderGrammarPartSelection();
            } else {
              grammarLoadingMessageEl.textContent =
                "Error: No valid grammar data found.";
            }
          },
          error: function (error) {
            console.error(error);
            grammarLoadingMessageEl.textContent = "Error loading grammar CSV.";
          },
        });
      }

      function renderGrammarPartSelection() {
        grammarLoadingMessageEl.style.display = "none";
        grammarPartSelectionEl.innerHTML = "";
        allGrammarData.forEach((part) => {
          const button = document.createElement("button");
          button.textContent = `Part ${part.part}: ${part.title}`;
          button.className =
            "w-full my-2 px-6 py-4 bg-gray-700 text-white font-semibold text-lg rounded-xl shadow-lg hover:bg-gray-800 transition-colors transform hover:scale-105";
          button.onclick = () => loadGrammarFlashcardSet(part.part);
          grammarPartSelectionEl.appendChild(button);
        });
      }

      function loadGrammarFlashcardSet(partId) {
        const part = allGrammarData.find((p) => p.part === partId);
        if (!part) return;

        currentGrammarData = part.groups.flatMap((group) => group.items);
        if (currentGrammarData.length === 0) {
          grammarLoadingMessageEl.textContent =
            "No grammar items found for this part.";
          grammarLoadingMessageEl.style.display = "block";
          return;
        }

        currentGrammarIndex = 0;
        grammarPartSelectionEl.style.display = "none";
        grammarFlashcardAppEl.style.display = "block";
        renderGrammarFlashcard();
      }

      function renderGrammarFlashcard() {
        if (!currentGrammarData.length) return;
        const currentItem = currentGrammarData[currentGrammarIndex];
        const randomExample =
          currentItem.examples[
            Math.floor(Math.random() * currentItem.examples.length)
          ];

        // FRONT: English example
        grammarFrontContentEl.querySelector("p").textContent = randomExample.en;

        // BACK: Japanese details + meters
        const strengthTagColor = getStrengthTagColor(currentItem.strength_tag);
        grammarStrengthTagEl.textContent = currentItem.strength_tag;
        grammarStrengthTagEl.style.backgroundColor = strengthTagColor;

        const directnessAvg =
          (currentItem.directness_range.min +
            currentItem.directness_range.max) /
          2;
        const politenessAvg =
          (currentItem.politeness_range.min +
            currentItem.politeness_range.max) /
          2;
        grammarDirectnessBarEl.style.width = `${Math.max(
          0,
          Math.min(100, directnessAvg)
        )}%`;
        grammarPolitenessBarEl.style.width = `${Math.max(
          0,
          Math.min(100, politenessAvg)
        )}%`;

        grammarNameEl.textContent = currentItem.name;
        grammarMeaningEl.textContent = currentItem.meaning;
        grammarFormEl.textContent = currentItem.form;
        grammarJapaneseExampleEl.textContent = randomExample.jp;
        grammarKeyPointEl.textContent = `Key Point: ${currentItem.key_point}`;

        grammarFlashcardEl.classList.remove("is-flipped");
      }

      function getStrengthTagColor(tag) {
        switch (tag) {
          case "⚡ Lively/emotional":
            return "#ef4444";
          case "⚡ Neutral":
            return "#6b7280";
          case "⚡ Very strong suddenness":
            return "#f59e0b";
          case "⚡⚡ Very strong risk":
            return "#b91c1c";
          case "⚡ Moderate contrast":
            return "#8b5cf6";
          case "⚡ Moderate cause":
            return "#10b981";
          default:
            return "#9ca3af";
        }
      }

      // UI helpers
      function showModal(title, message) {
        const modal = document.createElement("div");
        modal.className =
          "fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50";
        modal.innerHTML = `
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-center">
          <h3 class="text-xl font-bold mb-4">${title}</h3>
          <p class="text-gray-300">${message}</p>
          <button class="mt-4 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg" onclick="this.parentNode.parentNode.remove()">Close</button>
        </div>`;
        document.body.appendChild(modal);
      }
      function getKanji(w) {
        return (w?.kanji ?? w?.word ?? "").trim();
      }
      function getKana(w) {
        return (w?.hiragana ?? w?.kana ?? w?.reading ?? "").trim();
      }
      function getEnglish(w) {
        return (w?.english ?? w?.meaning ?? w?.gloss ?? "").trim();
      }

      function showToast(msg) {
        const t = document.createElement("div");
        t.className =
          "fixed bottom-4 left-1/2 -translate-x-1/2 bg-gray-800 text-gray-100 px-4 py-2 rounded shadow z-50";
        t.textContent = msg;
        document.body.appendChild(t);
        setTimeout(() => t.remove(), 2000);
      }

      function showPasswordScreen() {
        passwordUi.classList.remove("hidden");
        levelSelectionUi.classList.add("hidden");
        studyModeSelectionUi.classList.add("hidden");
        flashcardInputUi.classList.add("hidden");
        flashcardUi.classList.add("hidden");
        grammarUi.classList.add("hidden");
        subHeaderTextElement.textContent =
          "Enter the password to access your study materials.";
      }

      function showLevelSelection() {
        passwordUi.classList.add("hidden");
        levelSelectionUi.classList.remove("hidden");
        studyModeSelectionUi.classList.add("hidden");
        flashcardInputUi.classList.add("hidden");
        flashcardUi.classList.add("hidden");
        grammarUi.classList.add("hidden");
        subHeaderTextElement.textContent =
          "Choose your proficiency level to begin.";
      }

      function showStudyModeSelection() {
        passwordUi.classList.add("hidden");
        levelSelectionUi.classList.add("hidden");
        studyModeSelectionUi.classList.remove("hidden");
        flashcardInputUi.classList.add("hidden");
        flashcardUi.classList.add("hidden");
        grammarUi.classList.add("hidden");
        subHeaderTextElement.textContent = `You chose ${selectedLevel}. Now, choose a study mode.`;
        selectedLevelElement.textContent = selectedLevel;
      }

      function showFlashcardInput() {
        passwordUi.classList.add("hidden");
        levelSelectionUi.classList.add("hidden");
        studyModeSelectionUi.classList.add("hidden");
        flashcardInputUi.classList.remove("hidden");
        flashcardUi.classList.add("hidden");
        grammarUi.classList.add("hidden");
        subHeaderTextElement.textContent = ""; // no subheader

        if (apiGroups && apiGroups.length) {
          // Already have data — render grid now
          renderTopicProgressGrid(selectedLevel, apiGroups);
        } else {
          // First visit — fetch and then render
          loadVocabFromApi(selectedLevel).catch((e) =>
            showModal("API Error", e.message)
          );
        }
      }

      function showGrammarApp() {
        passwordUi.classList.add("hidden");
        levelSelectionUi.classList.add("hidden");
        studyModeSelectionUi.classList.add("hidden");
        flashcardInputUi.classList.add("hidden");
        flashcardUi.classList.add("hidden");
        grammarUi.classList.remove("hidden");
        subHeaderTextElement.textContent = `JLPT ${selectedLevel} Grammar`;

        if (selectedLevel === "N3") {
          fetchGrammarData();
        } else {
          showModal(
            "Coming Soon!",
            `The ${selectedLevel} grammar content is not yet available.`
          );
          showStudyModeSelection();
        }
      }

      // Events
      passwordBtn.addEventListener("click", () => {
        if (passwordInput.value === correctPassword) {
          localStorage.setItem(passwordCacheKey, correctPassword);
          showLevelSelection();
        } else {
          showModal("Incorrect Password", "Please try again.");
        }
      });

      document.querySelectorAll(".level-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          selectedLevel = e.currentTarget.dataset.level;
          showStudyModeSelection();
        });
      });
      function getPerDay() {
        return (
          parseInt(
            document.getElementById("per-day-input")?.value || "20",
            10
          ) || 20
        );
      }

      function updateHeader(topicKey, reviewCount, newCount) {
        subHeaderTextElement.textContent = `JLPT ${selectedLevel} — ${
          topicKey === "__ALL__" ? "All topics" : topicKey
        } · ${reviewCount} review · ${newCount} new`;
      }

      document
        .getElementById("settings-back-btn")
        ?.addEventListener("click", showStudyModeSelection);
      vocabModeBtn.addEventListener("click", showFlashcardInput);
      grammarModeBtn.addEventListener("click", showGrammarApp);
      backToLevelBtn.addEventListener("click", showLevelSelection);
      backToModeBtn.addEventListener("click", showStudyModeSelection);
      backFromGrammarBtn.addEventListener("click", showStudyModeSelection);
      document
        .getElementById("settings-back-btn")
        .addEventListener("click", showStudyModeSelection);

      document
        .getElementById("per-day-input")
        ?.addEventListener("change", () => {
          if (!apiGroups?.length) return;
          const inSession = !flashcardUi.classList.contains("hidden");
          if (!inSession) return;

          const perDay =
            parseInt(
              document.getElementById("per-day-input").value || "20",
              10
            ) || 20;
          const topicKeys = selectedTopics.size
            ? [...selectedTopics]
            : ["__ALL__"];
          const { list, reviewCount, newCount } = computeTodaySetMulti(
            selectedLevel,
            apiGroups,
            topicKeys,
            perDay
          );
          if (!list.length) return;

          cardList = list;
          currentCardIndex = 0;
          updateCard();

          const topicsLabel =
            topicKeys[0] === "__ALL__" ? "All topics" : topicKeys.join(", ");
          subHeaderTextElement.textContent = `JLPT ${selectedLevel} — ${topicsLabel} · ${reviewCount} review · ${newCount} new`;

          showToast(
            `Words/day updated · ${reviewCount} review / ${newCount} new`
          );
        });

      generateKanjiToEnglishBtn.addEventListener("click", () => {
        generateCards("kanji-to-english");
      });
      generateEnglishToKanjiBtn.addEventListener("click", () =>
        generateCards("english-to-kanji")
      );
      flashcardElement.addEventListener("click", flipCard);
      pronunciationBtn.addEventListener("click", speakWord);
      nextBtn.addEventListener("click", nextCard);
      previousBtn.addEventListener("click", previousCard);
      shuffleBtn.addEventListener("click", shuffleCards);

      document.getElementById("quiz-next-btn").addEventListener("click", () => {
        if (quizIndex < quizItems.length - 1) {
          quizIndex++;
          renderQuizQuestion();
        } else {
          // quiz finished
          showToast("Great job! Quiz complete.");
          document.getElementById("quiz-ui").classList.add("hidden");
          showStudyModeSelection(); // or go to a results screen
        }
      });

      document.getElementById("quiz-prev-btn").addEventListener("click", () => {
        if (quizIndex > 0) {
          quizIndex--;
          renderQuizQuestion();
        }
      });

      document.getElementById("quiz-exit-btn").addEventListener("click", () => {
        document.getElementById("quiz-ui").classList.add("hidden");
        showStudyModeSelection();
      });

      againBtn.addEventListener("click", () => {
        const w = cardList[currentCardIndex];
        if (!w) return;
        const srs = loadSRS(selectedLevel);
        const rec = ensureCard(srs, wid(w));
        scheduleNext(rec, /*wasCorrect*/ false);
        saveSRS(selectedLevel, srs);
        nextCard(); // move on
      });

      gotitBtn.addEventListener("click", () => {
        const w = cardList[currentCardIndex];
        if (!w) return;
        const srs = loadSRS(selectedLevel);
        const rec = ensureCard(srs, wid(w));
        scheduleNext(rec, /*wasCorrect*/ true);
        saveSRS(selectedLevel, srs);
        nextCard(); // move on
      });
      // Grammar flip + nav
      grammarFlashcardEl.addEventListener("click", () => {
        grammarFlashcardEl.classList.toggle("is-flipped");
      });
      grammarNextButtonEl.addEventListener("click", () => {
        currentGrammarIndex =
          (currentGrammarIndex + 1) % currentGrammarData.length;
        renderGrammarFlashcard();
      });
      grammarPrevButtonEl.addEventListener("click", () => {
        currentGrammarIndex =
          (currentGrammarIndex - 1 + currentGrammarData.length) %
          currentGrammarData.length;
        renderGrammarFlashcard();
      });
      grammarBackButtonEl.addEventListener("click", () => {
        grammarFlashcardAppEl.style.display = "none";
        grammarPartSelectionEl.style.display = "block";
      });
    </script>
  </body>
</html>
